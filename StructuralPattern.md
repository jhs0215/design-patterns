# 개요
구조 패턴(structural pattern)은 더 큰 구조를 형성하기 위해 어떻게 클래스와 객체를 합성하는가와 관련된 패턴입니다. 구조 **클래스** 패턴은 상속 기법을 이용하여 인터페이스나 구현을 복합합니다. 간단한 예를 하나 생각해 봅시다. 다중 상속을 통해서 둘 이상의 클래스를 하나로 만들 수 있습니다. 그 결과 이렇게 만들어진 클래스는 부모 클래스에 정의된 모든 특성들을 혼합하여 갖게 됩니다. 이 패턴은 서로 독립적으로 개발한 클래스 라이브러리를 마치 하나인 양 사용할 필요가 있을 때 매우 유용한 방법입니다. 또 한 가지 예가 적응자 패턴을 사용한 클래스 형태입니다. 일반적으로 적응자는 어떤 인터페이스가 다른 인터페이스를 따르게 만들어 서로 다른 인터페이스들의 통일된 추상을 제공합니다. 이를 가능하게 하려고, 적응자 클래스는 적응 대상 클래스(adaptee)에서 특성들을 상속받아, 적응 대상자에 정의된 인터페이스를 마치 자신이 제공하는 것처럼 보여줍니다.   
구조 **객체** 패턴은 인터페이스나 구현을 복합하는 것이 아니라 새로운 기능을 실현하기 위해 객체를 합성하는 방법을 제공합니다. 객체 합성이 갖는 추가된 유연성은 런타임에 복합 방법이나 대상을 변경할 수 있다는 점에서 나옵니다. 이는 정적인 클래스 복합을 사용해서는 불가능한 일입니다. 

# 적응자(ADAPTER)

## 의도
클래스의 인터페이스를 사용자가 기대하는 인터페이스 형태로 적응시킵니다. 서로 일치하지 않는 인터페이스를 갖는 클래스들을 함께 동작시킵니다. 

## 다른 이름
래퍼(Wapper)

## 활용성
- 기존 클래스를 사용하고 싶은데 인터페이스가 맞지 않을 때
- 아직 예측하지 못한 클래스나 실제 관련되지 않는 클래스들이 기존 클래스를 재사용하고자 하지만, 이미 정의된 재사용 가능한 클래스가 지금 요청하는 인터페이스를 꼭 정의하고 있지 않을 때. 다시 말해, 이미 만든 것을 재사용하고자 하나 이 재사용 가능한 라이브러리를 수정할 수 없을 때
- 이미 존재하는 여러 개의 서브클래스를 사용해야 하는데, 이 서브클래스들의 상속을 통해서 이들의 인터페이스를 다 개조한다는 것이 현실성이 없을 때. 객체 적응자를 써서 부모 클래스의 인터페이스를 변형하는 것이 더 바람직함. - 객체 적응자만 해당됨 -

## 참여자 
- Target : 사용자가 사용할 응용 분야에 종속적인 인터페이스를 정의하는 클래스로서, Shape을 예로 들 수 있습니다. 
- Client : Target 인터페이스를 만족하는 객체와 동작할 대상으로 DrawingEditor를 예로 들 수 있습니다. 
- Adaptee : 인터페이스의 적응이 필요한 기존 인터페이스를 정의하는 클래스로서, 적응대상자라고 합니다. TextView가 예가 될 수 있습니다. 
- Adapter : Target 인터페이스에 Adaptee의 인터페이스를 적응시키는 클래스입니다. 

## 결과
- Adapter 클래스는 Adaptee 클래스를 Target 클래스로 변형하는데, 이를 위해 Adaptee 클래스를 상속받아야 하기 때문에, 하나의 클래스와 이 클래스의 모든 서브클래스들을 개조할 때라면 클래스 적응자 방식을 사용할 수 없습니다. 즉, Adapter는 명시적으로 Adaptee를 상속받고 있을 뿐 Adaptee의 서브클래스들을 상속받는 것은 아니므로, Adaptee의 서브클래스에 정의된 기능들을 사용할 수 없습니다. 
- Adapter 클래스는 Adaptee 클래스를 상속하기 때문에 Adaptee에 정의된행동을 재정의할 수도 있습니다. 
- 한 개의 객체만 사용하면, Adaptee로 가기 위한 추가적인 포인터 간접화는 필요하지 않다. 

# 가교(BRIDGE)

## 의도
구현에서 추상을 분리하여, 이들이 독립적으로 다양성을 가질 수 있도록 합니다. 

## 다른이름
핸들/구현부(Handle/Body)

## 활용성
- 추상적 개념과 이에 대한 구현 사이의 지속적인 종속 관계를 피하고 싶을 때
- 추상적 개념과 구현 모두가 독립적으로 서브클래싱을 통해 확장되어야 할 때

## 참여자 
- Abstraction : 추상적 개념에 대한 인터페이스를 제공하고 객체 구현자에 대한 참조자를 관리합니다. 
- RefinedAbstraction : 추상적 개념에 정의된 인터페이스를 확장합니다. 
- Implementor : 구현 클래스에 해단 인터페이스를 제공합니다. 
- ConcreteImplementor : Implementor 인터페이스를 구현하는 것으로 실제적인 구현 내용을 담았습니다. 

## 결과
1. 인터페이스와 구현 분리
2. 확장성 제고
3. 구현 세부 사항을 사용자에게서 숨기기

# 복합체(COMPOSITE)

## 의도
부분과 전체의 계층을 표현하기 위해 객체들을 모아 트리 구조로 구성합니다. 사용자로 하여금 개별 객체와 복합 객체를 모두 동일하게 다룰 수 있도록 하는 패턴입니다. 

## 활용성
- 부분-전체의 객체 계통을 표현하고 싶을 때
- 사용자가 객체의 합성으로 생긴 복합 객체와 개개의 객체 사이의 차이를 알지 않고도 자기 일을 할 수 있도록 만들고 싶을 때. 사용자는 복합 구조의 모든 객체를 똑같이 취급하게 됩니다. 

## 참여자
- Component : 집합 관계에 정의될 모든 객체에 대한 인터페이스를 정의합니다. 모든 클래스에 해당하는 인터페이스에 대해서는 공통의 행동을 구현합니다. 전체 클래스에 속한 요소들을 관리하는 데 필요한 인터페이스를 정의합니다. 순환 구조에서 요소들을 포함하는 전체 클래스로 접근하는 데 필요한 인터페이스를 정의하며, 적절하다면 그 인터페이스를 구현합니다. 
- Leaf : 가장 말단의 객체, 즉 자식이 없는 객체를 나타냅니다. 객체 합성에 가장 기본이 되는 객체의 행동을 정의합니다. 
- Composite : 자식이 있는 구성요소에 대한 행동을 정의합니다. 자신이 복합하는 요소들을 저장하면서, Component 인터페이스에 정의된 자식 관련 연산을 구현합니다. 
- Client : Component 인터페이스를 통해 복합 구조 내의 객체들을 조작합니다. 

## 결과 
- 기본 객체와 복합 객체로 구성된 하나의 일관된 클래스 계통을 정의합니다. 기본 객체는 더 복합적인 객체들에 속해있을 수 있습니다. 물론 이 복합 객체 역시 다른 것에 속해있는 것일 수 있습니다. 그러나 사용자 코드는 일반화된 상위 개념의 객체를 조작하는 방식으로 프로그래밍하면, 런타임 기본 객체와 복합 객체를 구분하지 않고 일관되게 프로그래밍할 수 있게 됩니다. 
- 사용자의 코드가 단순해집니다. 사용자 코드는 복합 구조이나 단일 객체와 동일하게 다루는 코드로 작성되기 때문입니다. 즉, 사용자는 객체의 특성이 복합 구조인지 단일 구조인지조차 모르고 개발할 수 있습니다. 이런 구분이 필요치 않으므로 개발자의 코드에 "꼬리표-case-문장" 스타일의 함수를 쓸 필요가 없어지므로 코드가 단순해집니다. 
- 새로운 종류의 구성요소를 쉽게 추가할 수 있습니다. 새롭게 정의된 Composite 나 Leaf의 서브클래스들은 기존에 존재하는 구조들과 독립적으로 동작이 가능하게 됩니다. 그러므로 새로운 요소가 추가되었다고 해서 사용자의 프로그램이 변경될 필요는 전혀 없습니다. 
- 설계가 지나치게 범용성을 많이 가집니다. 새로운 요소를 쉽게 추가할 때의 단점은 복합체의 구성요소에 제약을 가하기 힘들다는 것입니다. 가끔 복합체가 오직 한 개의 구성요소만 가졌으면 할 때가 있습니다. Composite 클래스만으로 타입 시스템을 통해 이런 제약을 가할 수 없습니다. 런타임 점검이 들어가야 합니다. 

# 장식자(DECORATOR)

## 의도
객체에 동적으로 새로운 책임을 추가할 수 있게 합니다. 기능을 추가하려면, 서브클래스를 생성하는 것보다 융통성 있는 방법을 제공합니다. 

## 다른 이름
랩퍼(Wrapper)

## 활용성
- 동적으로 또는 투명하게, 다시 말해 다른 객체에 영향을 주지 않고 개개의 객체에 새로운 책임을 추가하기 위해 사용합니다. 
- 제거될 수 있는 책임에 대해서 사용합니다. 
- 실제 상속으로 서브클래스를 계속 만드는 방법이 실질적이지 못할 때 사용합니다. 너무 많은 수의 독립된 확장이 가능할 때 모든 조합을 지원하기 위해 이를 상속으로 해결하면 클래스 수가 폭발적으로 많아지게 됩니다. 아니면, 클래스 정의가 숨겨지든가, 그렇지 않더라도 서브클래싱을 할 수 없게 됩니다. 

## 참여자
- **Component**(VisualComponent) : 동적으로 추가할 서비스를 가질 가능성이 있는 객체들에 대한 인터페이스
- **ConcreteComponent**(TextView) : 추가적인 서비스가 실제로 정의되어야 할 필요가 있는 객체
- **Decorator** : Component 객체에 대한 참조자를 관리하여면서 Component에 정의된 인터페이스를 만족하도록 인터페이스를 정의
- **ConcreteDecorator**(BorderDecorator, ScrollDecorator) : Component에 새롭게 추가할 서비스를 실제로 구현하는 클래스

## 결과
1. **단순한 상속보다 설계의 융통성을 더 많이 증대시킬 수 있습니다.** 장식자 패턴은 객체에 새로운 행동을 추가할 수 있는 가장 효과적인 방법입니다. 장식자를 사용하면 장식자를 객체와 연결하거나 분리하는 작업을 통해 새로운 책임을 추가하거나 삭제하는 일이 런타임에 가능해집니다. 그러나 상속은 코드에서, 즉 정적으로 새로운 클래스를 추가해야만 추가적인 행동을 정의할 수 있는 방법입니다. 앞의 예를 상속으로 해결하려고 한다면, ScrollableTextView, BorderedTextView와 같은 클래스를 만들어야 합니다. 만약, 스크롤 기능과 테두리 기능 모두를 가지려면 추가한 ScrollableTextView, BorderedTextView를 상속받는 BorderedScrollableTextView를 또 생성해야 합니다. 이는 새로운 기능이 추가될 때마다 클래스의 수가 증가하는 결과를 낳게 됩니다. 그러나 장식자 패턴을 사용하면, 장식자의 조합을 통해서 새로운 책임도 조합할 수 있습니다. 이는 구조에 나타나는 바와 같이 Decorator 클래스와 Component 클래스 사이에 집합 관계가 정의되어 있어 Decorator는 Component 클래스의 인스턴스를 포함할 수 있는데, 이는 Component의 서브클래스인 ConcreteDecoratorA 클래스나 ConcreteDecoratorB 클래스의 인스턴스를 포함할 수 있다는 의미가 됩니다. 이렇게 Decorator의 서브클래스를 아무런 코드의 수정없이 포함할 수 있으므로, Decorator 클래스의 서브클래스 여러 개를 포함하면 여러 책임을 조합하는 결과가 됩니다. 
2. **클래스 계통의 상부측 클래스에 많은 기능이 누적되는 상황을 피할 수 있습니다.** 장식자 패턴은 책임 추가 작업에서 "필요한 비용만 그때 지불하는" 방법을 제공합니다. 지금 예상하지 못한 특성들을 한꺼번에 다 개발하기 위해 고민하고 노력하기보다는 발견하지 못하고 누락된 서비스들을 Decorator 객체를 통해 지속적으로 추가할 수 있습니다. 기능은 단순한 구성요소들의 조합으로 얻어질 수도 있습니다. 그러므로 응용프로그램 개발 시 현재 사용되지 않은 기능까지 개발하기 위해 시간과 노력을 투자할 필요는 없습니다. 이는 나중에 실제 그 기능이 필요할 때 새로운 종류의 Decorator를 개발함으로써 가능합니다. 
3. **장식자와 해당 그 장식자의 구성요소가 동일한 것은 아닙니다.** 장식자는 사용자에게 일관된 인터페이스를 제공하는 껍데기입니다. 그러므로 객체 식별자 관점에서 구성요소와 이를 둘러싼 Decorator 객체가 동일한 식별자를 가질 필요는 없습니다. 
4. **장식자를 사용함으로써 작은 규모의 객체들이 많이 생깁니다.** 장식자 패턴을 사용하는 설계에서는 규모가 작은 객체들의 수가 많아지는데, 이 객체들이 서로 다른점은 상호작용하는 방법에 있지, 클래스가 다르거나 변수에 정의된 값이 다른 것은 아닙니다. 즉, 클래스들이 어떻게 조합하여 새로운 모습과 기능을 만들어 내는가에 따라서 새로운 객체가 계속 만들어지기 때문입니다. 이때 이 객체\들을 잘 이해하고 있다면 시스템의 재정의가 쉽겠지만, 그렇지 않다면 객체들을 모두 이해하고 수정하는 과정이 복잡해집니다. 

## 구현
1. **인터페이스 일치시키기.** Decorator 객체의 인터페이스는 반드시 자신을 둘러싼 구성요소의 인터페이스를 만족해야 합니다. 따라서 ConcreteDecorator 클래스는 동일한 부모 클래스를 상속해야 합니다. 
2. **추상 클래스로 정의되는 Decorator 클래스 생략하기.** 간혹 추상 클래스인 Decorator 클래스를 정의할 필요가 없을 때도 있습니다. 이때는 Decorator 클래스에 정의할 책임이 한 가지밖에 존재하지 않습니다. 이것은 새로운 클래스들을 설계할 때 발생하기보다는 기존에 존재하는 클래스 계통을 사용해야 할 때 자주 일어납니다. 이때 구성요소에게 요청을 전달하는 Decorator 클래스의 책임을 ConcreteDecorator 클래스와 합칠 수 있습니다. 
3. **Component 클래스는 가벼운 무게를 유지하기.** 인터페이스를 만족하는지 확인하려면 구성요소와 Decorator 모두 동일한 부모 클래스인 Component 클래스를 상속받아야 합니다. 이럴 때 component 클래스를 가볍게 정의하는 것은 중요한 일입니다. 가볍게 정의한다는 의미는 연산에 해당하는 인터페이스만을 정의하고 무언가 저장할 수 있는 변수는 정의하지 말라는 의미입니다. 데이터 저장소를 정의하는 것은 서브클래스에서 할 일입니다. 이렇게 하지 않으면 Component 클래스가 복잡해지고 Component를 상속받는 여러 Decorator들도 복자하고 무거운 클래스가 되어 버립니다. 또한 Component 클래스에 너무 많은 서비스를 정의하는 것 역시 서브클래스에는 부담이 됩니다. 각 서브클래스는 자신에게 필요 없는 연산까지도 (불릴 때를 대비해서) 적절한 구현을 해야하는 추가 부담이 생기기 때문입니다. 
4. **객체의 겉포장을 변경할 것인가, 속을 변경할 것인가.** 흔히 장식이란 행동을 변경할 수 있도록 객체에 외장을 입힌 것으로 알고 있습니다. 이렇게 겉만 바꾸는 것이 아니라 내부도 변경할 수 있는데, 내부를 변경하는 대표적인 예가 뒤에서 살펴볼 전략 패턴입니다. 

# 퍼사드(FACADE)

## 의도 
한 서브시슽ㅁ 내의 인터페이스 집합에 대한 획일화된 하나의 인터페이스를 제공하는 패턴으로, 서브시스템을 사용하기 쉽도록 상위 수준의 인터페이스를 정의합니다. 

## 활용성 
- 복잡한 서브시스템에 대한 단순한 인터페이스를 제공이 필요할 때. 시스템 범위가 확장되면, 또한 구체적으로 설계되면 서브시스템은 계속 복잡해집니다. 또한 패턴을 적용하면 확장성을 고려하여 설꼐하기 때문에, 작은 클래스가 만들어지게 됩니다. 이런 과정은 서브시스템을 재사용 가능한 것으로 만들어 주고, 재정의할 수 있는 단위가 되도록 해 주기도 하지만, 실제 이런 상세한 재설계나 정제의 내용까지 파악할 필요가 없는 개발자들에게는 복잡해진 각각의 클래스들을 다 이해하면서 서브시스템을 사용하기란 어려운 일입니다. 이럴 때 퍼사드 패턴은 서브시스템에 대한 단순하면서도 기본적인 인터페이스를 제공함으로써 대부분의 개발자들에게 적합한 클래스 형태를 제공합니다. 
- 추상 개념에 대한 구현 클래스와 사용자 사이에 너무 많은 종속성이 존재할 때. 퍼사드의 사용을 통해 사용자와 다른 서브시스템 간의 결합도를 줄일 수 있습니다. 즉, 서브시스템에 정의된 모든 인터페이스가 공개되면 빈번한 메서드 호출이 있을 수 있으나, 이런 호출은 단순한 형태로 통합하여 제공하고 나머지 부분은 내부적으로 처리함으로써 사용자와 서브시스템 사이의 호출 횟수는 실질적으로 감소하게 되는 효과를 갖습니다. 
- 서브시스템을 계층화시킬 때. 퍼사드 패턴을 사용하여 각 서브시스템의 계층에 대한 접근점을 제공합니다. 서브시스템이 다른 서브시스템에 종속적이라 하더라도, 각자가 제공하는 퍼사드를 통해서만 대화를 진행하게 함으로써 서브시스템 간의 종속성을 줄일 수 있습니다. 이로써 서브시스템 내부 설계의 변경이 다른 서브시스템에 독립적으로 자유롭게 될 수 있는 것입니다. 

## 참여자
- **퍼사드**(Compiler) : 단순하고 일관된 통합 인터페이스를 제공하며, 서브시스템을 구성하는 어떤 클래스가 어떤 요청을 처리해야 하는지 알고 있으며, 사용자의 요청을 해당 서브시스템 객체에 전달합니다. 
- **서브시스템 클래스들**(Scanner, Parser, ProgramNode 등) : 서브시스템의 기능을 구현하고, Facade 객체로 할당된 작업을 실제로 처리하지만 Facade에 대한 아무런 정보가 없습니다. 즉, 이들에 대한 어떤 참조자도 가지고 있지 않습니다. 

## 결과
1. 서브시스템의 구성요소를 보호할 수 있습니다. 이로써 사용자가 다루어야 할 객체의 수가 줄어들며, 서브시스템을 쉽게 사용할 수 있습니다. 
2. 서브시스템과 사용자 코드 간의 결합도를 더욱 약하게 만듭니다. 서브시스템 내 정의된 요소들은 강하게 결합될 수 있습니다. 서브시스템과 사용자 간의 결합이 약하면, 서브시스템 내의 요소를 다양화하는 작업을 원활하게 할 수 있습니다. 
대규모 소프트웨어 시스템에서는 컴파일 의존성을 줄이는 것도 매우 중요합니다. 서브시스템 클래스가 바뀔 때 재컴파일을 최소화함으로써 어떻게든 시간을 절약하고 싶을 것입니다. 퍼사드를 사용해서 컴파일 의존성을 최소화하면 주요 서브시스템에서 작은 변경으로 들어가는 재컴파일을 제한할 수 있습니다. 퍼사드를 쓰면 다른 플랫폼으로 이식도 단순해집니다. 하나의 서브시스템을 빌드하면서 다른 모든 서브시스템까지 끌고 들어갈 때가 적어지기 때문입니다. 
3. 응용프로그램 쪽에서 서브시스템 클래스를 사용하는 것을 완전히 막지는 않습니다. 그러므로 Facade를 사용할지 서브시스템 클래스를 직접 사용할지 결정할 수 있습니다. 

## 구현 
1. **사용자와 서브시스템 간의 결합도 줄이기.** 사용자와 서브시스템 간의 의존성을 줄이는 방법은 Facade를 추상 클래스로 정의하고, 서브시스템을 나타내기 위해 이를 상속하는 구체 서브클래스를 정의하여 다른 구현을 정의하도록 하는 것입니다. 그러면 사용자는 Facade만 사용하기 때문에, 어떤 서브시스템의 구현이 사용되고 있는지 알 필요가 없게 됩니다. 
서브클래싱을 하지 않으려면 다른 서브시스템 객체들을 조합하여 Facade를 구성할 수도 있습니다. 또한 Facade를 수정하기 위해서는 하나 이상의 서브시스템 객체를 대체하면 간단하게 끝납니다. 
2. **서브시스템 클래스 중 공개할 것과 감출 것.** 서브시스템은 클래스와 유사합니다. 즉, 둘 다 인터페이스를 갖고 있으며 무엇인가를 감춥니다. 클래스는 상태와 연산을, 서브시스템은 클래스를 캡슐화합니다. 클래스의 인터페이스를 정의할 때 공개할지 말지를 고민하는 것처럼 서브시스템의 인터페이스도 공개할지 말지를 생각해 봐야 합니다. 
서브시스템의 공개 인터페이스는 사용자가 직접 접근할 수 있는 클래스들이고, 비공개 인터페이스는 서브시스템 자체가 됩니다. Facade 클래스는 공개 인터페이스의 일부입니다. 물론 단지 일부만은 아니겠만. 다른 서브시스템 클래스들도 모두 공개될 수 있습니다. Parser와 Scanner 클래스는 컴파일러에서 공개할 인터페이스들입니다. 

# 플라이급(FLYWEIGHT)

## 의도
공유(sharing)를 통해 많은 수의 소립(fine-grained) 객체들을 효과적으로 지원합니다. 

## 활용성
플라이급 패턴은 언제 사용하는가에 따라서 그 효과가 달라집니다. 다음의 경우에 사용할 수 있습니다. 
- 응용프로그램이 대량의 객체를 사용해야 할 때
- 객체의 수가 너무 많아져 저장 비용이 너무 높아질 때
- 대부분의 객체 상태를 부가적인 것으로 만들 수 있을 때
- 부가적인 속성들을 제거한 후 객체들을 조사해 보니 객체의 많은 묶음이 비교적 적은 수의 공유된 객체로 대체될 수 있을 때. 현재 서로 다른 객체로 간주한 이유는 이들 부가적인 속성 때문이었지 본질이 달랐던 것은 아닐 때
- 응용프로그램이 객체의 정체성에 의존하지 않을 때. 플라이급 객체들은 공유 될 수 있음을 의미하는데, 식별자가 있다는 것은 서로 다른 객체로 구별해야 한다는 의미이므로 플라이급 객체를 사용할 수 없습니다. 

## 참여자
- Flyweight(Glyph) : Flyweight가 받아들일 수 있고, 부가적 상태에서 동작해야햐는 인터페이스를 선언합니다. 
- ConcreteFlyweight(Character) : Flyweight 인터페이스를 구현하고 내부적으로 갖고 있어야 하는 본질적 상태에 대한 저장소를 정의합니다. ConcreteFlyweight 객체는 공유할 수 있는 것이어야 합니다. 그러므로 관리하는 어떤 상태라도 본질적인 것이어야 합니다. 
- UnsharedConcreteFlyweight(Row, Column) : 모든 플라이급 서브클래스들이 공유될 필요는 없습니다. Flyweight 인터페이스는 공유를 가능하게 하지만, 그것을 강요해서는 안 됩니다. UnsharedConcreteFlyweight 객체가 ConcreteFlyweight 객체를 자신의 자식으로 갖는 것은 흔한 일입니다. 
- FlyweightFactory : 플라이급객체를 생성하고 관리하며, 플라이급 객체가 제대로 공유되도록 보장합니다. 사용자가 플라이급 객체를 요청하면 FlyweightFactory 객체는 이미 존재하는 인스턴스를 제공하거나 만약 존재하지 않는다면 새로 생성합니다. 
- Client : 플라이급 객체에 대한 참조자를 관리하며 플라이급 객체의 부가적 상태를 저장합니다. 

## 협력방법
- 플라이급 객체가 기능을 수행하는데 필요한 상태가 본질적인 것인지 부가적인 것인지를 구분해야 합니다. 본질적 상태는 ConcreteFlyweight에 저장해야 하고, 부가적인 상태는 사용자가 저장하거나, 연산되어야 하는 다른 상태로 관리해야 합니다. 사용자는 연산을 호출할 때 자신에게만 필요한 부가적 상태를 플라이급 객체에 매개변수로 전달합니다. 
- 사용자는 ConcreteFlyweight의 인스턴스를 직접 만들 수 없습니다. 사용자는 ConcreteFlyweight 객체를 FlyweightFactory 객체에서 얻어야 합니다. 이렇게 해야 플라이급 객체가 공유될 수 있습니다. 

## 결과
- 공유해야 하는 인스턴스의 전체 수를 줄일 수 있습니다. 
- 객체별 본질적 상태의 양을 줄이 수 있습니다. 
- 부가적인 상태는 연산되거나 저장될 수 있습니다. 

##  구현 
1. **부가적 상태를 제외합니다.** 패턴의 활용 여부는 얼마나 쉽게 공유할 객체에서 부가적인 상태를 식별하고 이를 부닐하는강 달렸있습니다. 부가적인 상태 정보를 제거한다는 것은 객체의 저장소 공간을 그만큼 절약할 수 있다는 것입니다. 이론적으로 이들 부가적 상태 정보는 별도의 객체 구조에서 계산될 수 있는 것으로, 일반 상태를 저장할 때보다 더 작은 저장소가 필요합니다. 
문서 편집기의 예에서는 인쇄 정보의 앱을 별도의 구조에다가 저장할 수 있습니다. 즉, 각 문자 객체마다 폰트나 스타일을 저장하지 않습니다. 이 맵은 같은 인쇄 정보를 갖는 문자들을 추적합니다. 맵은 문자가 찍힐 때마다 인쇄 정보를 받아둡니다. 문서들은 몇몇의 폰트와 스타일을 사용하기 때문에, 각각의 글자마다 이 정보를 관리하기보다는 별도로 분리하여 저장하는 것이 훨씬 효과적입니다. 
2. **공유할 객체를 관리합니다.** 객체는 공유할 수 있으므로, 사용자는 직접 인스턴스를 만들면 안 됩니다. 그렇기 때문에 FlyweightFactory는 사용자가 특정한 플라이급 객체를 찾아내게 합니다. FlyweightFactory 객체는 연관 저장소를 써서 사용자가 자신의 관심 있는 Flyweight를 찾아볼 수 있게 해 줍니다. 예를들어, FlyweightFactory는 문자 코드로 색인된 Flyweight의 테이블을 별도로 관리합니다. 이것을 사용하여, 코드에 해당하는 Flyweight가 있으면 이를 반환하고, 없으면 새로 생성합니다. 
도한, 공유 가능성은 플라이급 객체가 필요하지 않을 때 그것을 해제하는 참조 카운팅 혹은 가비지 컬렉션 능력에 따라 좌우됩니다. 하지만 Flyweight수가 고정되었고, 또 작다면(ASCII 문자 집합을 위한 플라이급 객체가 그 예입니다.) 어느 쪽도 필요하지 않습니다. 즉, 이때는 이를 메모리에서 삭제할 필요없이 계속 두는 게 좋습니다. 

# 프록시(PROXY)

## 의도 
다른 객체에 대한 접근을 제겅하기 위한 대리자 또는 자리채움자 역할을 하는 객체를 둡니다. 

## 다른 이름
대리자(Surrogate)

## 활용성 
프록시 패턴은 단순한 포인터보다는 조금 더 다방현에 활요할 수 있거나 정교한 객체 참조자가 필요할 때 적용할 수 있습니다. 어떨 때인지 살펴봅시다. 
1. **원격지 프록시**(remote proxy)는 서로 다른 주소 공간에 존재하는 객체를 가리키는 대표 객체로, 로컬 환경에 위치합니다. NEXTSTEP은 이런 목적의 NXProxy 클래스를 사용하며, 코플리엔은 이런 종류의 프록시를 가리켜 "대사(Ambassador)"라고 하였습니다. 
2. **가상 프록시**(virtual proxy)는 요청이 있을 때만 필요한 고비용 객체를 생성합니다. 앞에서 예로 들엇던 ImageProxty가 여기에 해당합니다. 
3. **보호용 프록시**(protection proxy)는 원래 객체에 대한 실제 접근을 제어합니다. 이는 객체별로 접근 제어 권한이 다를 때 유용하게 사용할 수 있습니다. 예를 들어, Choices 운영체제의 KerelProXTes는 운영체제 객체에 대해 보호된 접근을 할 수 있도록 합니다. 
4. **스마트 참조자**(smart reference)는 원시 포인터의 대체용 객체로, 실제 객체에 접근이 일어날 때 추가적인 행동을 수행합니다. 전형적인 사용예는 다음과 같습니다. (1) 실제 객체에 대한 참조 횟수를 저장하다가 더는 참조가 없을 때 해당 객체를 자동으로 없앱니다.(**스마트 포인터**(smart pointer)라고도 합니다.) (2) 맨 처음 참조되는 시점에 영속적 저장소의 객체를 메모리로 옮깁니다. (3) 실제 객체에 접근하기 전에, 다른 객체가 그것을 변경하지 못하도록 실제 객체에 대해 잠금(lock)을 겁니다. 

## 참여자 
- **Proxy(ImageProxy)**  
(a) 실제로 참조할 대상에 대한 참조자를 관리합니다. RealSubject와 Subject 인터페이스가 동일하면 프록시는 Subject에 대한 참조자를 갖습니다.  
(b) Subject와 동일한 인터페이스를 제공하여 실제 대상을 대체할 수 있어야 합니다.   
(c) 실제 대상에 대한 접근을 제어하고 실제 대상의 생성과 삭제를 책임집니다.  
(d) Proxy의 종류에 따라서 다음을 수행합니다. 
    - **원격지 프록시**는 요청 메시지와 인자를 인코딩하여 이를 다른 주소 공간에 있는 실제 대상에게 전달합니다. 
    - **가상의 프록시**는 실제 대상에 대한 추가적 정보를 보유하여 실제 접근을 지연할 수 있도록 해야 합니다. 
    - **보호용 프록시**는 요청한 대상이 실제 요청할 수 있는 권한이 있는지 확인합니다. 
- **Subject(Graphic)** : RealSubject와 Proxy에 공통적인 인터페이스를 정의하여, RealSubject가 요청되는 곳에 Proxy를 사용할 수 있게 합니다. 
- **RealSubject(Image)** : 프록시가 대표하는 실제 객체입니다. 

## 협력 방법
프록시 클래스는 자신이 받은 요청을 RealSubject 객체에 전달합니다. 

## 결과
프록시 패턴은 어떤 객체에 접근할 때 추가적인 간접화 통로를 제공합니다. 이렇게 추가된 간접화 통로는 프로시의 종류에 따라서 여러 가지 쓰임새가 있습니다. 
1. 원격지 프록시는 객체가 다른 주소 공간에 존재한다는 사실을 숨길 수 있습니다. 
2. 가상 프록시는 요구에 따라 객체를 생성하는 등 처리를 최적화할 수 있습니다. 
3. 보호용 프록시 및 스마트 참조자는 객체가 접근할 때마다 추가 관리를 책임집니다. 객체를 생성할 것인지 삭제할 것인지를 관리합니다.  

Proxy 패턴이 사용자에게 숨길 수 있는 또 다른 최적화가 있습니다. 기록 시점 복사(copy-on-write)가 그것인데, 이 최겆ㄱ화는 요구가 들어올 때만 객체를 생성하는 개념과 관련 있습니다. 사실 덩치가 크고 복잡한 객체를 복사하려면 비용이 만만치 않습니다. 만약, 사본이 변경되지 않고 원본과 똑같다면, 굳이 이 비용을 물 필요가 없습니다. 프록시를 사용해서 복사 절차를 미룸으로써, 사본이 수정될 때만 실제 복사 비용을 물게 만드는 것입니다.  
이 기록 시점 복사 기능을 가능하게 하려면 원본의 참조 카운트를 관리해야 합니다. 프록시를 복사하는 연산은 이 원본에 대한 참조 카운트를 증가시키는 일 외에 다른 일은 하지 않습니다. 사용자가 이 원본을 수정하는 연산을 요청할 때 프록시가 실제로 복사를 진행하여 사본이 별도의 값을 가지게 합니다. 이렇게 되면 원본에 대한 참조자 수는 줄어듭니다. 이런 과정의 반복 속에 참조 카운트가 0이 되면 대상을 삭제합니다. 
기록 시점 복사는 중량급 객체에 대한 복사 비용을 현격하게 줄여줍니다. 

## 구현 
프록시 패턴을 구현하려면, 다음 언어적 특성을 사용할 수 있습니다. 
1. **C++에서는 멤버 접근 연산자를 오버로드합니다.** C++에서는 멤버 접근 연산자인 operator-> 연산의 오버로드 기능을 지원합니다. 이 연산자 오버로딩을 사용하면 포인터를 통해 해당 객체에 접근할 때마다 뭔가 추가적인 행동을 할 수 있습니다. 프록시가 단순한 포인터 역할만 할 때는 이 방식이 매우 유용합니다. 
2. **Proxy가 항상 자신이 상대할 실제 대상을 알 필요는 없습니다.** Proxy 클래스는 추상 인터페이스를 통해서만 대상과 일을 하므로, 각 RealSubject별로 Proxy클래스를 만들 필요가 없습니다. 프록시는 모든 RealSubject를 마치 하나의 클래스인 것처럼 하나의 인터페이스를 통해 사용하면 됩니다. 그러나 프록시는 RealSubject의 인스턴스를 생성해야 하는 시점이 되면 어떤 클래스의 인스턴스를 생성해야 하는지 알아야 합니다.


