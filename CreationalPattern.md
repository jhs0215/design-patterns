# 개요
생성 패턴(creational pattern)은 인스턴스를 만드는 절차를 추상화하는 패턴입니다. 이 범주에 해당하는 패턴은 객체를 생성/합성하는 방법이나 객체의 표현 방법과(소프트웨어) 시스템을 분리해 줍니다. 클래스 생성 패턴이 인스턴스로 만들 클래스를 다양하게 만들기 위한 용도로 상속을 사용하는 반면, 객체 생성 패턴은 인스턴스화 작업을 다른 객체에게 떠넘길 수도 있습니다.   
생성 패턴은 시스템이 상속보다는 복합 방법을 사용하는 쪽으로 진화되어 가면서 더 중요해지고 있습니다. 이 때문에 고정된 행동 집합을 정의하는 것보다는, 더 복잡한 행동을 만드는 데 필요한 구성요소가 될 수 있는 기본적인 행동 집합을 정의하는 쪽에 더 많은 관심과 노력이 들어가고 있습니다. 그러므로 특정 행동을 수행하는 클래스를 만들려면 단순하게 하나의 클래스를 인스턴스화하는 일 이상의 품이 들어갑니다.  
생성 패턴이 나오면 항상 따라다니는 이야기가 두 개 있습니다. 첫째, 생성 패턴은 시스템이 어떤 구체 클래스를 사용하는지에 대한 정보를 캡슐화합니다. 둘째, 생성 패턴은 이들 클래스의 인스턴스들이 어떻게 만들고 어떻게 서로 맞붙는지에 대한 부분을 완전히 가려줍니다. 결론적으로, 생성 패턴을 이용하면 **무엇이** 생성되고, **누가** 이것을 생성하며, 이것이 **어떻게** 생성되는지, **언제** 생성할 것인지 결정하는 데 유연성을 확보할 수 있게 됩니다.  
생성 패턴으로 분류되는 패턴은 여러 개인데, 이런 여러 생성 패턴들은 서로 보완적일 수도 있고 선택되기 위해 서로 경쟁적일 수도 있습니다. 즉, 동일한 문제 해결을 위해서 어떤 생성 패턴을 사용해야 할지 결정을 내리기 어렵습니다.  
인스턴스를 생성하고 복합하는 방법에 해당하는 부분과 이들 인스턴스를 사용하는 프로그램을 분리하고자 할 때 어떤 패턴을 적용해야 하는지 판단하기는 어렵습니다. 예를 들어, 원형 패턴과 추상 팩토리 패턴 중 무엇을 선택할지 고민해야 할 때가 있습니다. 어떨 때는 또 이들이 서로 보완적일 수도 있지요. 예를 들어, 빌더 패턴은 어떤 구성요소를 만들지 구현하는 데에 다른 생성 패턴 중 하나를 사용할 수 있습니다. 원형 패턴은 자기 자신을 구현을 위해 단일체 패턴을 사용하기도 합니다. 

# 추상 팩토리(ABSTRACT FACTORY)

## 의도
상세화된 서브클래스를 정의하지 않고도 서로 관련성이 있거나 독립적인 여러 객체의 군을 생성하기 위한 인터페이스를 제공합니다. 

## 다른이름
키트(Kit)

## 활용성
- 객체가 생성되거나 구성, 표현되는 방식과 무관하게 시스템을 독립적으로 만들고자 할 때
- 여러 제품군 중 하나를 선택해서 시스템을 설정해야 하고 한번 구성한 제품을 다른 것으로 대체할 수 있을 때
- 관련된 제품 객체들이 함께 사용되도록 설계되었고, 이 부분에 대한 제약이 외부에도 지켜지도록 하고 싶을 때
- 제품에 대한 클래스 라이브러리를 제공하고, 그들의 구현이 아닌 인터페이스를 노출시키고 싶을 때

## 참여자 
- AbstractFactory : 개념적 제품에 대한 객체를 생성하는 연산으로 인터페이스를 정의합니다. 
- ConcreteFactory : 구체적인 제품에 대한 객체를 생성하는 연산을 구현합니다. 
- AbstractProduct : 개념적 제품 객체에 대한 인터페이스를 정의합니다. 
- ConcreteProduct : 구체적으로 팩토리가 생성할 객체를 정의하고, AbstractProduct가 정의하는 인터페이스를 구현합니다. 
- Client : AbstractFactory와 AbstractProduct 클래스에 선언된 인터페이스를 사용합니다. 

## 결과
1. 구체적인 클래스를 분리합니다. 
2. 제품군을 쉽게 대체할 수 있도록 합니다. 
3. 제품 사이의 일관성을 증진시킵니다.
4. 새로운 종류의 제품을 제공하기 어렵습니다.

## 예제 코드 
AbstractRunner

# 빌더(BUILDER)

## 의도
복잡한 객체를 생성하는 방법과 표현하는 방법을 정의하는 클래스를 별도로 분리하여, 서로 다른 표현이라도 이를 생성할 수 있는 동일한 절차를 제공할 수 있도록 합니다. 

## 활용성
- 복합 객체의 생성 알고리즘이 이를 합성하는 요소 객체들이 무엇인지 이들의 조립 방법에 독립적일 때
- 합성할 객체들의 표현이 서로 다르더라도 생성 절차에서 이를 지원해야 할 때

## 참여자
- Builder : Product 객체의 일부 요소들을 생성하기 위한 추상 인터페이스를 정의합니다. 
- ConcreteBuilder : Builder 클래스에 정의된 인터페이스를 구현하며, 제품의 부품들을 모아 빌더를 복합합니다. 생성한 요소의 표현을 정의하고 관리합니다. 또한 제품을 검색하는 데 필요한 인터페이스를 제공합니다.
- Director : Builder 인터페이스를 사용하는 객체를 합성합니다. 
- Product : 생성할 복합 객체를 표현합니다. ConcreteBuilder는 제품의 내부 표현을 구축하고 복합 객체가 어떻게 구성되는지에 관한 절차를 정의합니다. 

## 결과
1. 제품에 대한 내부 표현을 다양하게 변화할 수 있습니다. 
2. 생성과 표현에 필요한 코드를 분리합니다. 

## 예제 코드
BuilderRunner

# 팩토리 메소드(FACTORY METHOD)

## 의도
객체를 생성하기 위해 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 서브클래스가 내리도록 합니다. 

## 다른 이름
가상 생성자(Virtual Constructor)

## 활용성
- 어떤 클래스가 자신이 생성해야 하는 객체의 클래스를 예측할 수 없을 때
- 생성할 객체를 기술하는 책임을 자신의 서브클래스가 지정했으면 할 때
- 객체 생성의 책임을 몇 개의 보조 서브클래스 가운데 하나에게 위임하고, 어떤 서브클래스가 위임자인지에 대한 정보를 국소화시키고 싶을 때

## 참여자
- Product : 팩토리 메소드가 생성하는 객체의 인터페이스를 정의합니다. 
- ConcreteProduct : Product 클래스에 정의된 인터페이스를 실제로 구현합니다. 
- Creator : Product 타입의 객체를 반환하는 팩토리 메서드를 선언합니다. Creator 클래스는 팩토리 메서드를 기본적으로 구현하는데, 이 구현에서는 ConcreteProduct 객체를 반환합니다. 또한 Product 객체의 생성을 위해 팩토리 메서드를 호출합니다. 
- ConcreteCreator : 팩토리 메서드를 재정의하여 ConcreteProduct의 인스턴스를 반환합니다. 

## 결과 
1. 서브클래스에 대한 훅(hook) 메서드를 제공합니다. 
2. 병렬적인 클래스 계통을 연결하는 역할을 담당합니다. 

# 원형(PROTOTYPE)

## 의도 
원형이 되는 인스턴스를 사용하여 생성할 객체의 종류를 명시하고, 이렇게 만든 견본을 복사해서 새로운 객체를 생성합니다. 

## 활용성 
- 인스턴스화할 클래스를 런타임에 지정할 때
- 제품 클래스 계통과 병렬적으로 만드는 팩토리 클래스를 피하고 싶을 때
- 클래스의 인스턴스들이 서로 다른 상태 조합 중에 어느 하나일 때 원형 패턴을 씁니다. 이들을 미리 원형으로 초기화해 두고, 나중에 이를 복제해서 사용하는 것이 매번 필요한 상태 조합의 값들을 수동적으로 초기화하는 것보다 더 편리할 수도 있습니다. 

## 참여자
- Prototype : 자신을 복제하는 데 필요한 인터페이스를 정의합니다. 
- ConcretePrototype : 자신을 복제하는 연산을 구현합니다. 
- Client : 원형에 자기 자신의 복제를 요청하여 새로운 객체를 생성합니다. 

## 결과
1. 런타임에 새로운 제품을 추가하고 삭제할 수 있습니다. 
2. 값들을 다양화함으로써 새로운 객체를 명세합니다. 
3. 구조를 다양화함으로써 새로운 객체를 명세할 수 있습니다. 
4. 서브클래스의 수를 줄입니다. 
5. 동적으로 클래스에 따라 응용프로그램을 설정할 수 있습니다. 

# 단일체(SINGLETON)

## 의도
오직 한 개의 클래스 인스턴스만을 갖도록 보장하고, 이에 대한 전역적인 접근점을 제공합니다. 

## 활용성
- 클래스의 인스턴스가 오직 하나여야 함을 보장하고, 잘 정의된 접근점으로 모든 사용자가 접근할 수 있도록 해야 할 때
- 유일한 인스턴스가 서브클래싱으로 확장되어야 하며, 사용자는 코드의 수정없이 확장된 서브클래스의 인스턴스를 사용할 수 있어야 할 때

## 참여자 
- Singleton : instance() 연산을 정의하여, 유일한 인스턴스로 접근할 수 있도록 합니다. Instance() 연산은 클래스 연산입니다. - C++에서는 정적 멤버함수입니다. - 유일한 인스턴스를 생성하는 책임을 맡습니다. 

## 결과
1. 유일하게 존재하는 인스턴스로의 접근을 통제합니다. 
2. 이름 공간을 좁힙니다. 
3. 연산 및 표현의 정제를 허용합니다. 
4. 인스턴스의 개수를 변경하기가 자유롭습니다. 
5. 클래스 연산을 사용하는 것보다 훨씬 유연한 방법입니다. 